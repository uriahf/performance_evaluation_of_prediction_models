{
  "hash": "6ad9df4afda3a0251bbf57d565f1e5db",
  "result": {
    "markdown": "---\ntitle: \"Performance Evaluation of Prediction Models\"\nauthor: \"Uriah Finkel\"\nformat:\n  revealjs:\n    theme:  [solarized, custom.scss]\n    incremental: true\n---\n\n\n## Agenda\n\n-   Introduction to performance metrics and curves for prediction models.\n\n-   For medical prediction models the most common outcome is a binary outcome, therefore this will be the focus of the lecture.\n\n## Code for Performance Metrics and Curves\n\nAll interactive plots in this presentation were created with [**rtichoke**](https://uriahf.github.io/rtichoke/) (I am the author üëã).\n\nYou are also invited to explore [**rtichoke blog**](https://rtichoke-blog.netlify.app/) for reproducible examples and some theory.\n\n## rtichoke blog {background-iframe=\"https://rtichoke-blog.netlify.app\"}\n\n## Motivation\n\n### Why using performance metrics? ü§î\n\n-   Choosing between different candidate models.\n-   Choosing between candidate features\n\n### Relevant Criteria besides Performance\n\n-   How difficult is it to implement the model?\n\n-   How difficult is it to explain the model?\n\n## Categories of Performance Metrics and Curves\n\n-   **Discrimination**: Model's ability to separate between events and non-events.\n\n-   **Calibration**: Agreement between predicted probabilities and the prevalence of the outcomes.\n\n-   **Utility**: The usefulness of the model in terms of decision-making.\n\n## Colors\n\n::: columns\n::: {.column width=\"50%\"}\n### [Green]{style=\"color: green;\"} {style=\"font-size: 100px;\"}\n\n### **üôÇ** {style=\"text-align: center; font-size: 180px;\"}\n:::\n\n::: {.column width=\"50%\"}\n### [Red]{style=\"color: red;\"} {style=\"font-size: 100px;\"}\n\n### **üôÅ** {style=\"text-align: center; font-size: 180px;\"}\n:::\n:::\n\n## Colors\n\n::: columns\n::: {.column width=\"50%\"}\n### [Green]{style=\"color: green;\"} {style=\"font-size: 100px;\"}\n\n![](Maccabi_Haifa_FC_logo.svg){fig-align=\"center\" width=\"200\"}\n:::\n\n::: {.column width=\"50%\"}\n### [Red]{style=\"color: red;\"} {style=\"font-size: 100px;\"}\n\n::: {style=\"height:49px; width:100%; clear:both;\"}\n:::\n\n![](Hapoel_Haifa_Football_Club_Logo.png){fig-align=\"center\" width=\"200\"}\n:::\n:::\n\n## Discrimination\n\nThis is the most known and used category of performance metrics and curves.\n\n## Discrimination\n**üíä <br> ü§¢**\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-28ab27b848000dba2cf4\" class=\"reactable html-widget\" style=\"width:auto;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-28ab27b848000dba2cf4\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"type\":[\"Real Positive\",\"Real Negative\"],\"predicted_positive\":[\"TP\",\"FP\"],\"predicted_negative\":[\"FN\",\"TN\"]},\"columns\":[{\"accessor\":\"type\",\"name\":\"\",\"type\":\"character\",\"align\":\"left\",\"headerStyle\":{\"fontWeight\":100},\"minWidth\":200,\"style\":{\"fontWeight\":100}},{\"accessor\":\"predicted_positive\",\"name\":\"Predicted Positive\",\"type\":\"character\",\"align\":\"center\",\"headerStyle\":{\"fontWeight\":100},\"minWidth\":200,\"style\":[{\"fontWeight\":600,\"background\":\"lightgreen\"},{\"fontWeight\":600,\"background\":null}]},{\"accessor\":\"predicted_negative\",\"name\":\"Predicted Negative\",\"type\":\"character\",\"align\":\"center\",\"headerStyle\":{\"fontWeight\":100},\"minWidth\":200,\"style\":[{\"fontWeight\":600},{\"fontWeight\":600}]}],\"sortable\":false,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"inline\":true,\"theme\":{\"backgroundColor\":\"#fdf6e3\"},\"dataKey\":\"0e87a4d202a6e42067acce914af1bd56\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Discrimination\n\n#### Performance Metrics derived by using a Probability Threshold:\n\nMost Performance Metrics are estimated by using a Probability Threshold in order to classify each probability to Predicted Negative or Predicted Positive.\n\nThis type of Binarization is being used when the intervention carries a potential risk and there is a trade-off of risks between the intervention and the outcome.\n\n## Discrimination\n\n#### Performance Metrics derived by using a Predicted Positives Conditional Rate:\n\nA different type of Binarization is the Predicted Positives Conditional Rate (also known in healthcare as \"Risk Percentile\").\n\nPPCR (Predicted Positives Condition Rate:\n\n$\\begin{aligned} \\ {\\scriptsize \\frac{\\text{TP + FP}}{\\text{TP + FP + TN + FN}}}\\end{aligned}$\n\n## Discrimination - Common Performance Metrics:\n\n<br>\n\nSensitivity: $\\begin{aligned} \\ {\\scriptsize \\frac{\\text{TP}}{\\text{TP + FN}} = \\text{Prob( Predicted Positive | Real Positive )}}\\end{aligned}$\n\n<br>\n\nSpecificity: $\\begin{aligned} \\ {\\scriptsize \\frac{\\text{TP}}{\\text{TP + FN}} = \\text{Prob( Predicted Positive | Real Positive )} } \\end{aligned}$\n\n## Discrimination - ROC Curve\n",
    "supporting": [
      "performance_evaluation_of_prediction_models_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"performance_evaluation_of_prediction_models_files/libs/core-js-2.5.3/shim.min.js\"></script>\r\n<script src=\"performance_evaluation_of_prediction_models_files/libs/react-17.0.0/react.min.js\"></script>\r\n<script src=\"performance_evaluation_of_prediction_models_files/libs/react-17.0.0/react-dom.min.js\"></script>\r\n<script src=\"performance_evaluation_of_prediction_models_files/libs/reactwidget-1.0.0/react-tools.js\"></script>\r\n<script src=\"performance_evaluation_of_prediction_models_files/libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\r\n<script src=\"performance_evaluation_of_prediction_models_files/libs/reactable-binding-0.3.0/reactable.js\"></script>\r\n"
      ],
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n\r\n      // dispatch for htmlwidgets\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for reveal\r\n    if (window.Reveal) {\r\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\r\n        fireSlideChanged(event.previousSlide, event.currentSlide);\r\n      });\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}